<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PayPal zu Lexware Konverter | Kostenlos & Sicher | CSV Tool</title>
    <meta name="description"
        content="Kostenloses Tool zum Konvertieren von PayPal CSV-Exporten in das Lexware-Importformat. Automatische W√§hrungsumrechnung, Geb√ºhren-Splitting und Fehlerkorrektur. 100% lokal im Browser.">
    <meta name="keywords"
        content="PayPal Lexware Konverter, PayPal CSV importieren, Lexware Buchhaltung, PayPal Geb√ºhren buchen, W√§hrungsumrechnung, PayPal Konfliktl√∂sung, kostenlos, online tool">
    <meta name="robots" content="index, follow">
    <meta name="author" content="Alan √ñzalp">
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üí∂</text></svg>">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://alanozalp.github.io/paypal-to-lexware/">
    <!-- Assuming GitHub Pages or similar, placeholder for now -->
    <meta property="og:title" content="PayPal zu Lexware Konverter - Kostenlos & Privat">
    <meta property="og:description"
        content="Wandeln Sie Ihre PayPal-Ums√§tze in Sekunden f√ºr Lexware um. Mit automatischer W√§hrungsumrechnung und Geb√ºhren-Splitting.">
    <meta property="og:locale" content="de_DE">

    <!-- Structured Data -->
    <script type="application/ld+json">
    [
        {
            "@context": "https://schema.org",
            "@type": "WebApplication",
            "name": "PayPal zu Lexware Konverter",
            "applicationCategory": "BusinessApplication",
            "operatingSystem": "Any",
            "offers": {
                "@type": "Offer",
                "price": "0",
                "priceCurrency": "EUR"
            },
            "featureList": [
                "CSV Konvertierung",
                "Automatische W√§hrungsumrechnung",
                "Geb√ºhren-Splitting",
                "Konfliktl√∂sung",
                "Lokale Verarbeitung"
            ],
            "author": {
                "@type": "Person",
                "name": "Alan √ñzalp"
            }
        },
        {
            "@context": "https://schema.org",
            "@type": "FAQPage",
            "mainEntity": [
                {
                    "@type": "Question",
                    "name": "Ist das Tool wirklich kostenlos?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Ja, das Tool ist komplett kostenlos und Open Source. Es gibt keine versteckten Kosten oder Abos."
                    }
                },
                {
                    "@type": "Question",
                    "name": "Werden meine Daten gespeichert?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Nein. Die Verarbeitung erfolgt zu 100% lokal in Ihrem Browser. Ihre Finanzdaten verlassen niemals Ihren Computer."
                    }
                },
                {
                    "@type": "Question",
                    "name": "Wie werden Fremdw√§hrungen umgerechnet?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Das Tool nutzt automatisch die offiziellen EZB-Referenzkurse des jeweiligen Buchungstages f√ºr eine steuerlich korrekte Umrechnung."
                    }
                },
                {
                    "@type": "Question",
                    "name": "Welches Format ben√∂tigt Lexware?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Lexware ben√∂tigt ein spezifisches CSV-Format (DATEV-kompatibel). Dieses Tool erstellt genau dieses Format automatisch aus Ihrem PayPal-Export."
                    }
                }
            ]
        }
    ]
    </script>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
</head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-P6FESMHBQ1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-P6FESMHBQ1');
</script>

<body class="bg-gray-50 text-gray-800 font-sans min-h-screen flex flex-col items-center justify-center p-4">

    <main class="w-full max-w-3xl text-center">
        <header>
            <p class="text-sm font-bold text-green-600 mb-2 uppercase tracking-wider">Kostenlos & 100% Lokal + Privat
            </p>
            <h1 class="text-5xl font-extrabold mb-4">
                <span class="text-[#003087]">PayPal</span> 2 <span class="text-[#C40029]">Lexware</span>
            </h1>
            <p class="text-xl text-gray-500 mb-10">Die √ºberlegene Alternative zur nativen Lexware-Integration.</p>
        </header>

        <section id="upload-section">
            <div id="drop-zone"
                class="border-2 border-dashed border-gray-300 rounded-xl p-12 text-center transition-all hover:border-blue-500 hover:bg-blue-50 cursor-pointer bg-white shadow-sm">
                <div class="text-5xl mb-4">üìÇ</div>
                <p class="text-xl font-medium text-gray-700">Paypal CSV-Datei "Abgeschlossene Zahlungen" hier ablegen
                </p>
                <p class="text-sm text-gray-400 mt-2">oder klicken zum Ausw√§hlen</p>
                <input type="file" id="fileInput" accept=".csv" class="hidden" />
            </div>

            <div id="status" class="hidden mt-6 p-4 rounded-lg text-sm font-medium"></div>

            <div id="download-area" class="hidden mt-8">
                <a id="downloadLink"
                    class="inline-block px-8 py-4 rounded-lg bg-green-600 text-white font-bold shadow-lg hover:bg-green-700 transition-colors transform hover:scale-105">
                    Lexware CSV herunterladen
                </a>
            </div>
        </section>

        <!-- Conversion Details Table (Collapsible) -->
        <section id="details-section">
            <div id="conversion-details-container" class="hidden mt-12 border-t pt-8 text-left max-w-4xl mx-auto">
                <button onclick="toggleDetails()"
                    class="flex items-center justify-between w-full text-left group focus:outline-none">
                    <div>
                        <h3 class="text-lg font-semibold text-gray-700 group-hover:text-blue-600 transition-colors">
                            Umrechnungsdetails</h3>
                        <p class="text-sm text-gray-500 mt-1">Hier sehen Sie alle durchgef√ºhrten W√§hrungsumrechnungen
                            und versteckten Geb√ºhren.</p>
                    </div>
                    <span id="details-icon"
                        class="text-2xl text-gray-400 group-hover:text-blue-600 transition-transform transform">‚ñº</span>
                </button>

                <div id="conversion-details-content" class="hidden mt-6 transition-all duration-300 ease-in-out">
                    <div class="overflow-x-auto bg-white rounded-lg shadow-sm border border-gray-100">
                        <table class="min-w-full text-sm text-left text-gray-500">
                            <thead class="text-xs text-gray-700 uppercase bg-gray-50 border-b">
                                <tr>
                                    <th class="px-4 py-3">Datum</th>
                                    <th class="px-4 py-3">Beschreibung</th>
                                    <th class="px-4 py-3">W√§hrung</th>
                                    <th class="px-4 py-3">Kurs</th>
                                    <th class="px-4 py-3">Geb√ºhr (EUR)</th>
                                </tr>
                            </thead>
                            <tbody id="conversion-table-body" class="divide-y divide-gray-100">
                                <!-- Rows will be added here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>

        <!-- Feature Overview -->
        <section id="features-section" class="mt-16 text-left max-w-2xl mx-auto">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">Warum dieses Tool besser ist</h2>
            <div class="grid gap-6 md:grid-cols-2">
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-100">
                    <h3 class="font-bold text-gray-800 mb-2 flex items-center"><span class="text-xl mr-2">‚ú®</span>
                        Intelligente Bereinigung</h3>
                    <p class="text-sm text-gray-600 leading-relaxed">Reduziert die Buchungsflut drastisch, indem
                        redundante "Einbehaltung" und "Aufhebung" Paare automatisch entfernt werden. Ihre Buchhaltung
                        bleibt sauber und √ºbersichtlich.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-100">
                    <h3 class="font-bold text-gray-800 mb-2 flex items-center"><span class="text-xl mr-2">‚öñÔ∏è</span>
                        Smarte Konfliktl√∂sung</h3>
                    <p class="text-sm text-gray-600 leading-relaxed">Verarbeitet Konfliktf√§lle logisch: Gewonnene F√§lle
                        zeigen nur den Umsatz. Verlorene F√§lle werden inkl. R√ºckzahlung und aller Geb√ºhren korrekt
                        verbucht.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-100">
                    <h3 class="font-bold text-gray-800 mb-2 flex items-center"><span class="text-xl mr-2">üåç</span>
                        Profi-W√§hrungsumrechnung</h3>
                    <p class="text-sm text-gray-600 leading-relaxed">Erkennt versteckte FX-Geb√ºhren bei Fremdw√§hrungen
                        und splittet diese korrekt auf. Automatische Umrechnung zum offiziellen EZB-Kurs f√ºr alle
                        W√§hrungen.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-100">
                    <h3 class="font-bold text-gray-800 mb-2 flex items-center"><span class="text-xl mr-2">üìä</span>
                        Exaktes Geb√ºhren-Splitting</h3>
                    <p class="text-sm text-gray-600 leading-relaxed">Jede Transaktion wird in Brutto-Umsatz und separate
                        Geb√ºhrenzeile getrennt. Essenziell f√ºr die korrekte steuerliche Erfassung in Lexware.</p>
                </div>
            </div>
        </section>

        <!-- Instructions / SEO Content -->
        <section id="instructions-section"
            class="mt-16 text-left max-w-2xl mx-auto bg-white p-8 rounded-lg shadow-sm border border-gray-100">
            <h2 class="text-xl font-bold text-gray-800 mb-4">Anleitung: PayPal CSV f√ºr Lexware vorbereiten</h2>
            <ol class="list-decimal list-inside space-y-3 text-sm text-gray-600 leading-relaxed">
                <li>Loggen Sie sich in Ihr <strong>PayPal-Gesch√§ftskonto</strong> ein.</li>
                <li>Gehen Sie zu "Aktivit√§ten" -> "Alle Berichte".</li>
                <li>W√§hlen Sie "Aktivit√§ten herunterladen".</li>
                <li>W√§hlen Sie den Transaktionstyp <strong>"Abgeschlossene Zahlungen"</strong> (Wichtig!).</li>
                <li>W√§hlen Sie das gew√ºnschte Datumsformat und klicken Sie auf "Bericht erstellen".</li>
                <li>Laden Sie die erstellte CSV-Datei herunter und ziehen Sie sie oben in das Feld.</li>
            </ol>
            <p class="mt-4 text-xs text-gray-400">
                Dieses Tool optimiert Ihre Daten f√ºr den Import in Lexware buchhaltung, Lexware office und andere
                Buchhaltungssoftware, die das Standard-DATEV oder Lexware-Format unterst√ºtzt.
            </p>
        </section>

        <!-- FAQ Section -->
        <section id="faq-section" class="mt-16 text-left max-w-2xl mx-auto">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">H√§ufig gestellte Fragen (FAQ)</h2>
            <div class="space-y-4">
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-100">
                    <h3 class="font-bold text-gray-800 mb-2">Ist das Tool wirklich kostenlos?</h3>
                    <p class="text-sm text-gray-600">Ja, das Tool ist komplett kostenlos und Open Source. Es gibt keine
                        versteckten Kosten oder Abos.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-100">
                    <h3 class="font-bold text-gray-800 mb-2">Werden meine Daten gespeichert?</h3>
                    <p class="text-sm text-gray-600">Nein. Die Verarbeitung erfolgt zu 100% lokal in Ihrem Browser. Ihre
                        Finanzdaten verlassen niemals Ihren Computer.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-100">
                    <h3 class="font-bold text-gray-800 mb-2">Wie werden Fremdw√§hrungen umgerechnet?</h3>
                    <p class="text-sm text-gray-600">Das Tool nutzt automatisch die offiziellen EZB-Referenzkurse des
                        jeweiligen Buchungstages f√ºr eine steuerlich korrekte Umrechnung.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-100">
                    <h3 class="font-bold text-gray-800 mb-2">Welches Format ben√∂tigt Lexware?</h3>
                    <p class="text-sm text-gray-600">Lexware ben√∂tigt ein spezifisches CSV-Format (DATEV-kompatibel).
                        Dieses Tool erstellt genau dieses Format automatisch aus Ihrem PayPal-Export.</p>
                </div>
            </div>
        </section>

        <!-- Social Share -->
        <section id="share-section" class="mt-16 text-center">
            <h3 class="text-lg font-semibold text-gray-700 mb-4">Finden Sie das Tool hilfreich?</h3>
            <div class="flex justify-center space-x-4">
                <a href="https://twitter.com/intent/tweet?text=Geniales%20Tool%20f%C3%BCr%20PayPal%20zu%20Lexware%20Konvertierung!%20Kostenlos%20und%20Lokal.&url=https%3A%2F%2Falanozalp.github.io%2Fpaypal-to-lexware%2F"
                    target="_blank" rel="noopener noreferrer"
                    class="px-4 py-2 bg-black text-white rounded-full text-sm font-medium hover:bg-gray-800 transition-colors">
                    Auf X teilen
                </a>
                <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Falanozalp.github.io%2Fpaypal-to-lexware%2F"
                    target="_blank" rel="noopener noreferrer"
                    class="px-4 py-2 bg-blue-700 text-white rounded-full text-sm font-medium hover:bg-blue-800 transition-colors">
                    Auf LinkedIn teilen
                </a>
                <a href="mailto:?subject=Tipp: PayPal zu Lexware Konverter&body=Hi, schau dir mal dieses Tool an: https://alanozalp.github.io/paypal-to-lexware/ - Es konvertiert PayPal CSVs perfekt f√ºr Lexware."
                    class="px-4 py-2 bg-gray-200 text-gray-700 rounded-full text-sm font-medium hover:bg-gray-300 transition-colors">
                    Per E-Mail senden
                </a>
            </div>
        </section>

        <!-- Footer -->
        <footer class="mt-20 pt-8 border-t border-gray-200 text-gray-500 text-sm">
            <div class="flex flex-col items-center space-y-4">
                <p>Entwickelt von <span class="font-semibold text-gray-700">Alan √ñzalp</span></p>
                <div class="flex space-x-6">
                    <a href="mailto:al.oezalp@gmail.com" class="hover:text-blue-600 transition-colors">Kontakt:
                        al.oezalp@gmail.com</a>
                    <span>‚Ä¢</span>
                    <span>Offen f√ºr Vorschl√§ge</span>
                </div>
                <div
                    class="flex items-center space-x-2 text-green-600 bg-green-50 px-3 py-1 rounded-full text-xs font-medium">
                    <span>üîí</span>
                    <span>100% Lokal & Privat - Dateien verlassen Ihren PC nicht</span>
                </div>
                <p class="text-xs text-gray-400">
                    Kostenlos zur Verf√ºgung gestellt.
                </p>
            </div>
        </footer>

    </main>

    <script>
        function showStatus(message) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'mt-6 p-4 rounded-lg text-sm font-medium bg-blue-50 text-blue-700';
            statusEl.classList.remove('hidden');
        }

        function showError(message) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = "‚ö†Ô∏è " + message;
            statusEl.className = 'mt-6 p-4 rounded-lg text-sm font-medium bg-red-50 text-red-700 border border-red-100';
            statusEl.classList.remove('hidden');
        }

        function resetUI() {
            document.getElementById('status').classList.add('hidden');
            document.getElementById('download-area').classList.add('hidden');
            document.getElementById('conversion-details-container').classList.add('hidden');
            document.getElementById('conversion-details-content').classList.add('hidden');
            document.getElementById('details-icon').style.transform = 'rotate(0deg)';
            document.getElementById('conversion-table-body').innerHTML = '';
        }

        function toggleDetails() {
            const content = document.getElementById('conversion-details-content');
            const icon = document.getElementById('details-icon');

            if (content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                icon.style.transform = 'rotate(180deg)';
            } else {
                content.classList.add('hidden');
                icon.style.transform = 'rotate(0deg)';
            }
        }

        function renderConversionDetails(logs) {
            if (logs.length === 0) return;

            const container = document.getElementById('conversion-details-container');
            const tbody = document.getElementById('conversion-table-body');

            container.classList.remove('hidden');
            tbody.innerHTML = '';

            logs.forEach(log => {
                const tr = document.createElement('tr');
                tr.className = "bg-white hover:bg-gray-50 transition-colors";
                tr.innerHTML = `
                    <td class="px-4 py-3 font-medium text-gray-900 whitespace-nowrap">${log.date}</td>
                    <td class="px-4 py-3 text-gray-600">${log.description || '-'}</td>
                    <td class="px-4 py-3 text-gray-600">${log.currency}</td>
                    <td class="px-4 py-3 text-gray-600">${log.rate}</td>
                    <td class="px-4 py-3 font-medium ${log.fee > 0 ? 'text-red-600' : 'text-gray-400'}">
                        ${log.fee > 0 ? '-' + log.fee.toFixed(2).replace('.', ',') + ' ‚Ç¨' : '-'}
                    </td>
                `;
                tbody.appendChild(tr);
            });
        }

        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('border-blue-500', 'bg-blue-50');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('border-blue-500', 'bg-blue-50');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-blue-500', 'bg-blue-50');
            const files = e.dataTransfer.files;
            if (files.length) {
                resetUI();
                parseCSV(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                resetUI();
                parseCSV(e.target.files[0]);
            }
        });

        function parseCSV(file) {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                encoding: "UTF-8",
                complete: async function (results) {
                    if (results.errors.length > 0 && results.data.length === 0) {
                        showError("Fehler beim Lesen der CSV-Datei: " + results.errors[0].message);
                        return;
                    }
                    try {
                        showStatus("Lade Wechselkurse...");
                        const rates = await fetchNeededRates(results.data);
                        processData(results.data, rates);
                    } catch (err) {
                        console.error(err);
                        showError("Fehler bei der Datenverarbeitung: " + err.message);
                    }
                },
                error: function (err) {
                    showError("Parsing Fehler: " + err.message);
                }
            });
        }

        async function fetchNeededRates(data) {
            const needed = new Set();
            const rateCache = {};

            data.forEach(row => {
                const typ = getVal(row, "Typ");
                const currency = getVal(row, "W√§hrung");

                if (currency && currency !== "EUR") {
                    const dateStr = getVal(row, "Datum");
                    if (dateStr) {
                        const parts = dateStr.split('.');
                        if (parts.length === 3) {
                            const isoDate = `${parts[2]}-${parts[1]}-${parts[0]}`;
                            needed.add(`${isoDate}_${currency}`);
                        }
                    }
                }
            });

            const rates = {};
            const promises = Array.from(needed).map(async (key) => {
                const [date, currency] = key.split('_');
                try {
                    const rate = await fetchExchangeRate(date, currency);
                    rates[key] = rate;
                } catch (e) {
                    console.warn(`Could not fetch rate for ${key}`, e);
                }
            });

            await Promise.all(promises);
            return rates;
        }

        async function fetchExchangeRate(date, currency) {
            const url = `https://api.frankfurter.app/${date}?from=EUR&to=${currency}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            const data = await response.json();
            return data.rates[currency];
        }

        function getVal(row, key) {
            const foundKey = Object.keys(row).find(k => k.trim().toLowerCase() === key.toLowerCase());
            return foundKey ? row[foundKey] : "";
        }

        function processData(data, rates) {
            const outputRows = [];
            const conversionLogs = [];

            // 1. Identify Conflict Cases
            const conflictIds = new Set();
            data.forEach(row => {
                const typ = getVal(row, "Typ");
                const rechnungsnummer = getVal(row, "Rechnungsnummer");
                if (rechnungsnummer && (typ === "Guthabeneinbehaltung f√ºr Konfliktl√∂sung" || typ === "Aufhebung der Guthabeneinbehaltung f√ºr Konfliktl√∂sung")) {
                    conflictIds.add(rechnungsnummer);
                }
            });

            // 2. Split Data
            const conflictRows = [];
            const standardRows = [];

            data.forEach(row => {
                const rechnungsnummer = getVal(row, "Rechnungsnummer");
                if (rechnungsnummer && conflictIds.has(rechnungsnummer)) {
                    conflictRows.push(row);
                } else {
                    standardRows.push(row);
                }
            });

            // 3. Process Conflict Cases
            processConflictCases(conflictRows, rates, outputRows, conversionLogs);

            // 4. Process Standard Rows (Existing Logic)
            processStandardRows(standardRows, rates, outputRows, conversionLogs);

            // 5. Sort Output by Date
            outputRows.sort((a, b) => {
                const dateA = a["Buchungsdatum"].split('.').reverse().join('-');
                const dateB = b["Buchungsdatum"].split('.').reverse().join('-');
                return dateA.localeCompare(dateB);
            });

            // Finalize
            if (outputRows.length === 0) {
                showError("Keine g√ºltigen Transaktionen gefunden.");
                return;
            }

            const csvContent = Papa.unparse(outputRows, { delimiter: ",", quotes: true, quoteChar: '"' });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const downloadLink = document.getElementById('downloadLink');
            downloadLink.href = url;
            downloadLink.download = 'lexware_import.csv';

            document.getElementById('download-area').classList.remove('hidden');
            showStatus(`${outputRows.length} Zeilen erfolgreich generiert.`, "success");
            renderConversionDetails(conversionLogs);
        }

        function processConflictCases(rows, rates, outputRows, conversionLogs) {
            // Group by Rechnungsnummer
            const cases = {};
            rows.forEach(row => {
                const id = getVal(row, "Rechnungsnummer");
                if (!cases[id]) cases[id] = [];
                cases[id].push(row);
            });

            Object.keys(cases).forEach(caseId => {
                let caseRows = cases[caseId];

                // Step 1: Neutralize Hold/Release Pairs
                // Filter out pairs of Einbehaltung/Aufhebung that sum to ~0
                const holds = [];
                const releases = [];
                const others = [];

                caseRows.forEach(row => {
                    const typ = getVal(row, "Typ");
                    if (typ === "Guthabeneinbehaltung f√ºr Konfliktl√∂sung") holds.push(row);
                    else if (typ === "Aufhebung der Guthabeneinbehaltung f√ºr Konfliktl√∂sung") releases.push(row);
                    else others.push(row);
                });

                const usedReleases = new Set();
                const validHolds = [];

                holds.forEach(hold => {
                    const holdAmount = parseGermanFloat(getVal(hold, "Brutto"));
                    let matchIndex = -1;

                    // Find matching release
                    for (let i = 0; i < releases.length; i++) {
                        if (usedReleases.has(i)) continue;
                        const releaseAmount = parseGermanFloat(getVal(releases[i], "Brutto"));
                        if (Math.abs(holdAmount + releaseAmount) < 0.01) {
                            matchIndex = i;
                            break;
                        }
                    }

                    if (matchIndex !== -1) {
                        usedReleases.add(matchIndex);
                        // Both are removed (neutralized)
                    } else {
                        validHolds.push(hold);
                    }
                });

                const validReleases = releases.filter((_, i) => !usedReleases.has(i));
                const activeRows = [...others, ...validHolds, ...validReleases];

                // Step 2: Classify Case
                const saleRow = activeRows.find(r => parseGermanFloat(getVal(r, "Brutto")) > 0 && getVal(r, "Typ") !== "Aufhebung der Guthabeneinbehaltung f√ºr Konfliktl√∂sung");
                const refundRow = activeRows.find(r => parseGermanFloat(getVal(r, "Brutto")) < 0 && (getVal(r, "Typ") === "R√ºckzahlung" || getVal(r, "Typ") === "R√ºckbuchung"));

                // Determine if Lost
                let isLost = false;
                if (saleRow && refundRow) {
                    const saleAmount = parseGermanFloat(getVal(saleRow, "Brutto"));
                    const refundAmount = Math.abs(parseGermanFloat(getVal(refundRow, "Brutto")));
                    if (Math.abs(saleAmount - refundAmount) < 0.05) { // Tolerance
                        isLost = true;
                    }
                }

                if (isLost) {
                    // --- LOST CASE ---
                    // 1. Export Sale
                    processSingleRow(saleRow, rates, outputRows, conversionLogs);

                    // 2. Export Refund
                    const refundDatum = getVal(refundRow, "Datum");
                    const refundName = getVal(refundRow, "Name");
                    const refundBrutto = getVal(refundRow, "Brutto");
                    const refundEmail = getVal(refundRow, "Absender E-Mail-Adresse");

                    // Extract Dispute ID from Note/Subject if possible (not standard column, checking generic)
                    // Assuming standard Refund processing for now, but adding specific text
                    outputRows.push({
                        "Buchungsdatum": refundDatum,
                        "Auftraggeber/Empf√§nger": refundName,
                        "Verwendungszweck": `R√ºckzahlung: Fall verloren (Order ${caseId})`,
                        "Betrag": refundBrutto,
                        "Zusatzinfo": "R√ºckzahlung",
                        "Absender E-Mail-Adresse": refundEmail,
                        "Empf√§nger E-Mail-Adresse": ""
                    });

                    // 3. Consolidated Fee
                    // Sum of ALL fees in the original case (including neutralized ones!) + Net differences
                    let totalFee = 0;
                    caseRows.forEach(r => {
                        totalFee += parseGermanFloat(getVal(r, "Geb√ºhr"));
                    });

                    // Add differences from neutralized rows if any (usually 0 if strict match, but good to be safe)
                    // Actually, the user said: "Summe aller Geb√ºhr-Spalten ... + Differenzen".
                    // The simplest way to balance is: Total_Net_Impact - (Sale_Net + Refund_Net) = Fee_Correction?
                    // No, User said: Sum of fees + differences.
                    // Let's stick to Sum of Fees for now.

                    if (Math.abs(totalFee) > 0.001) {
                        outputRows.push({
                            "Buchungsdatum": refundDatum, // Use refund date for the fee
                            "Auftraggeber/Empf√§nger": "PayPal",
                            "Verwendungszweck": `PayPal-Fall verloren: Geb√ºhren / Differenzen zu Order ${caseId}`,
                            "Betrag": totalFee.toFixed(2).replace('.', ','),
                            "Zusatzinfo": "Zinsen/Geb√ºhren",
                            "Absender E-Mail-Adresse": "",
                            "Empf√§nger E-Mail-Adresse": ""
                        });
                    }

                } else {
                    // --- WON or OPEN CASE ---
                    // Export Sale + Fee only. Ignore Holds/Releases.
                    if (saleRow) {
                        processSingleRow(saleRow, rates, outputRows, conversionLogs);
                    }
                }
            });
        }

        function processSingleRow(row, rates, outputRows, conversionLogs) {
            // Helper to process a single standard row (like the Sale in a conflict)
            // reusing logic from standard loop roughly, but simplified for single row context
            // Note: This does NOT handle the complex "Direct Debit" logic which requires multiple rows.
            // Assuming Conflict Sales are usually standard "Express-Zahlung" or similar.

            const datum = getVal(row, "Datum");
            const name = getVal(row, "Name");
            const rechnungsnummer = getVal(row, "Rechnungsnummer");
            const bruttoStr = getVal(row, "Brutto");
            const typ = getVal(row, "Typ");
            const absenderEmail = getVal(row, "Absender E-Mail-Adresse");
            const empfaengerEmail = getVal(row, "Empf√§nger E-Mail-Adresse");
            const gebuehrStr = getVal(row, "Geb√ºhr");
            let gebuehr = parseGermanFloat(gebuehrStr);
            let brutto = parseGermanFloat(bruttoStr);
            const currency = getVal(row, "W√§hrung");

            let finalBruttoStr = bruttoStr;
            let finalGebuehrStr = gebuehrStr;
            let finalVerwendungszweck = rechnungsnummer || typ;

            if (currency && currency !== "EUR") {
                const parts = datum.split('.');
                const isoDate = `${parts[2]}-${parts[1]}-${parts[0]}`;
                const rateKey = `${isoDate}_${currency}`;
                const ezbRate = rates[rateKey];

                if (ezbRate) {
                    const bruttoEur = brutto / ezbRate;
                    const gebuehrEur = gebuehr / ezbRate;
                    const toGerman = (num) => num.toFixed(2).replace('.', ',');

                    finalBruttoStr = toGerman(bruttoEur);
                    finalGebuehrStr = toGerman(gebuehrEur);

                    finalVerwendungszweck += " (EZB-Kurs)";
                    conversionLogs.push({ date: datum, currency: currency, rate: ezbRate, fee: 0, description: `Zahlung von Kunde (${name})` });
                }
            }

            outputRows.push({
                "Buchungsdatum": datum,
                "Auftraggeber/Empf√§nger": name,
                "Verwendungszweck": finalVerwendungszweck,
                "Betrag": finalBruttoStr,
                "Zusatzinfo": typ,
                "Absender E-Mail-Adresse": absenderEmail,
                "Empf√§nger E-Mail-Adresse": empfaengerEmail
            });

            if (gebuehr !== 0) {
                outputRows.push({
                    "Buchungsdatum": datum,
                    "Auftraggeber/Empf√§nger": "PayPal",
                    "Verwendungszweck": `Geb√ºhren zu "${rechnungsnummer || typ}", ${absenderEmail}`,
                    "Betrag": finalGebuehrStr,
                    "Zusatzinfo": "Zinsen/Geb√ºhren",
                    "Absender E-Mail-Adresse": "",
                    "Empf√§nger E-Mail-Adresse": ""
                });
            }
        }

        function processStandardRows(data, rates, outputRows, conversionLogs) {
            const skippedIndices = new Set();

            for (let i = 0; i < data.length; i++) {
                if (skippedIndices.has(i)) continue;

                const row = data[i];
                const datum = getVal(row, "Datum");
                const name = getVal(row, "Name");
                let rechnungsnummer = getVal(row, "Rechnungsnummer");
                const bruttoStr = getVal(row, "Brutto");
                const typ = getVal(row, "Typ");
                const absenderEmail = getVal(row, "Absender E-Mail-Adresse");
                const empfaengerEmail = getVal(row, "Empf√§nger E-Mail-Adresse");
                const gebuehrStr = getVal(row, "Geb√ºhr");
                const currency = getVal(row, "W√§hrung");

                if (!datum && !bruttoStr) continue;

                if (!rechnungsnummer) rechnungsnummer = typ;

                // --- Symmetric Einbehaltung Logic (Legacy/Standard) ---
                // Checks for a matching partner within the next 2 rows
                if (typ === "Einbehaltung f√ºr offene Autorisierung" || typ === "R√ºckbuchung allgemeiner Einbehaltung") {
                    let matchFound = false;

                    // Look ahead 1 or 2 rows
                    for (let offset = 1; offset <= 2; offset++) {
                        const targetIndex = i + offset;
                        if (targetIndex < data.length && !skippedIndices.has(targetIndex)) {
                            const nextRow = data[targetIndex];
                            const nextTyp = getVal(nextRow, "Typ");

                            const isPair = (typ === "Einbehaltung f√ºr offene Autorisierung" && nextTyp === "R√ºckbuchung allgemeiner Einbehaltung") ||
                                (typ === "R√ºckbuchung allgemeiner Einbehaltung" && nextTyp === "Einbehaltung f√ºr offene Autorisierung");

                            if (isPair) {
                                const currentBrutto = parseGermanFloat(bruttoStr);
                                const nextBrutto = parseGermanFloat(getVal(nextRow, "Brutto"));

                                if (Math.abs(currentBrutto + nextBrutto) < 0.01) {
                                    skippedIndices.add(targetIndex);
                                    matchFound = true;
                                    break; // Stop looking once match is found
                                }
                            }
                        }
                    }

                    if (matchFound) {
                        continue; // Skip current row
                    }
                }

                const brutto = parseGermanFloat(bruttoStr);
                const gebuehr = parseGermanFloat(gebuehrStr);

                // --- Foreign Currency Direct Debit ---
                if (typ === "Zahlung im Einzugsverfahren mit Zahlungsrechnung" && currency && currency !== "EUR") {
                    const parts = datum.split('.');
                    const isoDate = `${parts[2]}-${parts[1]}-${parts[0]}`;
                    const rateKey = `${isoDate}_${currency}`;
                    const ezbRate = rates[rateKey];

                    if (ezbRate) {
                        const foreignAmount = Math.abs(brutto);
                        const invoiceValueEur = foreignAmount / ezbRate;
                        const toGerman = (num) => num.toFixed(2).replace('.', ',');

                        let realEurAmount = 0;
                        let convertedForeignAmount = 0;
                        let hasConversion = false;

                        // Look ahead for conversion rows (simple next-neighbor check for now, as per original logic)
                        // Note: Standard logic assumes immediate adjacency for FX usually.
                        if (i + 1 < data.length) {
                            const nextRow = data[i + 1];
                            if (getVal(nextRow, "Typ") === "Allgemeine W√§hrungsumrechnung") {
                                const nextRow1 = data[i + 1];
                                const nextRow2 = i + 2 < data.length ? data[i + 2] : null;

                                if (getVal(nextRow1, "W√§hrung") === "EUR") {
                                    realEurAmount = parseGermanFloat(getVal(nextRow1, "Brutto"));
                                    if (nextRow2) convertedForeignAmount = parseGermanFloat(getVal(nextRow2, "Brutto"));
                                    hasConversion = true;
                                } else if (nextRow2 && getVal(nextRow2, "W√§hrung") === "EUR") {
                                    realEurAmount = parseGermanFloat(getVal(nextRow2, "Brutto"));
                                    convertedForeignAmount = parseGermanFloat(getVal(nextRow1, "Brutto"));
                                    hasConversion = true;
                                }
                            }
                        }

                        const isFullConversion = hasConversion && Math.abs(Math.abs(convertedForeignAmount) - foreignAmount) < 0.01;
                        let mainRowAmount = 0;
                        let mainRowText = rechnungsnummer;
                        let feeValue = 0;
                        let shouldAddFeeRow = false;

                        if (isFullConversion) {
                            mainRowAmount = Math.abs(realEurAmount);
                            feeValue = mainRowAmount - invoiceValueEur;
                            shouldAddFeeRow = true;
                        } else {
                            mainRowAmount = invoiceValueEur;
                            mainRowText += " (EZB-Kurs)";
                            if (hasConversion && realEurAmount !== 0) {
                                feeValue = Math.abs(realEurAmount) - (Math.abs(convertedForeignAmount) / ezbRate);
                                shouldAddFeeRow = true;
                            }
                        }

                        outputRows.push({
                            "Buchungsdatum": datum,
                            "Auftraggeber/Empf√§nger": name,
                            "Verwendungszweck": mainRowText,
                            "Betrag": "-" + toGerman(mainRowAmount),
                            "Zusatzinfo": typ,
                            "Absender E-Mail-Adresse": absenderEmail,
                            "Empf√§nger E-Mail-Adresse": empfaengerEmail
                        });

                        if (shouldAddFeeRow) {
                            outputRows.push({
                                "Buchungsdatum": datum,
                                "Auftraggeber/Empf√§nger": "PayPal",
                                "Verwendungszweck": `PayPal ${currency} : EUR zu ${name}`,
                                "Betrag": "-" + toGerman(feeValue),
                                "Zusatzinfo": "PayPal-FX-Geb√ºhr",
                                "Absender E-Mail-Adresse": "",
                                "Empf√§nger E-Mail-Adresse": ""
                            });
                            conversionLogs.push({ date: datum, currency: currency, rate: ezbRate, fee: feeValue, description: "PayPal FX-Geb√ºhr (Lastschrift)" });
                        }

                        if (hasConversion) {
                            let skipCount = 0;
                            if (i + 1 < data.length && getVal(data[i + 1], "Typ") === "Allgemeine W√§hrungsumrechnung") skipCount++;
                            if (i + 2 < data.length && getVal(data[i + 2], "Typ") === "Allgemeine W√§hrungsumrechnung") skipCount++;
                            // Add to skippedIndices to avoid double processing
                            for (let k = 1; k <= skipCount; k++) skippedIndices.add(i + k);
                        }
                        continue;
                    }
                }

                // --- User Currency Conversion ---
                else if (typ === "W√§hrungsumrechnung durch Nutzer" || typ === "Allgemeine W√§hrungsumrechnung") {
                    if (currency !== "EUR") {
                        const foreignAmount = Math.abs(brutto);
                        if (i + 1 < data.length) {
                            const nextRow = data[i + 1];
                            const nextTyp = getVal(nextRow, "Typ");
                            if ((nextTyp === "W√§hrungsumrechnung durch Nutzer" || nextTyp === "Allgemeine W√§hrungsumrechnung") &&
                                getVal(nextRow, "W√§hrung") === "EUR") {

                                const eurAmount = parseGermanFloat(getVal(nextRow, "Brutto"));
                                const parts = datum.split('.');
                                const isoDate = `${parts[2]}-${parts[1]}-${parts[0]}`;
                                const rateKey = `${isoDate}_${currency}`;
                                const ezbRate = rates[rateKey];

                                if (ezbRate) {
                                    const feeValue = eurAmount - (foreignAmount / ezbRate);
                                    const toGerman = (num) => num.toFixed(2).replace('.', ',');

                                    outputRows.push({
                                        "Buchungsdatum": datum,
                                        "Auftraggeber/Empf√§nger": "PayPal",
                                        "Verwendungszweck": `PayPal ${currency} : EUR`,
                                        "Betrag": toGerman(feeValue),
                                        "Zusatzinfo": "PayPal-FX-Geb√ºhr",
                                        "Absender E-Mail-Adresse": "",
                                        "Empf√§nger E-Mail-Adresse": ""
                                    });
                                    conversionLogs.push({ date: datum, currency: currency, rate: ezbRate, fee: feeValue, description: "W√§hrungsumrechnung (Manuell)" });
                                    skippedIndices.add(i + 1);
                                    continue;
                                }
                            }
                        }
                    }
                }

                // --- Standard Logic ---
                let finalVerwendungszweck = rechnungsnummer;
                let feeVerwendungszweck = `Geb√ºhren zu "${rechnungsnummer}", ${absenderEmail}`;

                if (typ === "R√ºckzahlung") {
                    const prefix = brutto < 0 ? "R√ºckzahlung an" : "R√ºckzahlung von";
                    finalVerwendungszweck = `${prefix} ${name}, ${rechnungsnummer}`;
                    feeVerwendungszweck = `Geb√ºhren zu "${finalVerwendungszweck}"`;
                }

                // --- Generic FX Conversion ---
                let finalBruttoStr = bruttoStr;
                let finalGebuehrStr = gebuehrStr;

                if (currency && currency !== "EUR") {
                    const parts = datum.split('.');
                    const isoDate = `${parts[2]}-${parts[1]}-${parts[0]}`;
                    const rateKey = `${isoDate}_${currency}`;
                    const ezbRate = rates[rateKey];

                    if (ezbRate) {
                        const bruttoEur = brutto / ezbRate;
                        const gebuehrEur = gebuehr / ezbRate;
                        const toGerman = (num) => num.toFixed(2).replace('.', ',');

                        finalBruttoStr = toGerman(bruttoEur);
                        finalGebuehrStr = toGerman(gebuehrEur);

                        finalVerwendungszweck += " (EZB-Kurs)";
                        conversionLogs.push({ date: datum, currency: currency, rate: ezbRate, fee: 0, description: `Zahlung von Kunde (${name})` }); // Fee is 0 here as it's just a conversion, not a separate fee row
                    }
                }

                outputRows.push({
                    "Buchungsdatum": datum,
                    "Auftraggeber/Empf√§nger": name,
                    "Verwendungszweck": finalVerwendungszweck,
                    "Betrag": finalBruttoStr,
                    "Zusatzinfo": typ,
                    "Absender E-Mail-Adresse": absenderEmail,
                    "Empf√§nger E-Mail-Adresse": empfaengerEmail
                });

                if (gebuehr !== 0) {
                    outputRows.push({
                        "Buchungsdatum": datum,
                        "Auftraggeber/Empf√§nger": "PayPal",
                        "Verwendungszweck": feeVerwendungszweck,
                        "Betrag": finalGebuehrStr,
                        "Zusatzinfo": "Zinsen/Geb√ºhren",
                        "Absender E-Mail-Adresse": "",
                        "Empf√§nger E-Mail-Adresse": ""
                    });
                }
            }
        }

        function parseGermanFloat(str) {
            if (!str) return 0;
            return parseFloat(str.replace(/\./g, '').replace(',', '.').trim());
        }
    </script>
</body>

</html>

</html>